<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: query/condition/ConditionParser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: query/condition/ConditionParser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

require('insulin').factory('ndm_ConditionParser',
  ['ndm_assert'], ndm_ConditionParserProducer);

function ndm_ConditionParserProducer(assert) {
  /** A recursive decent parser for a SQL condition (WHERE or ON).
  This parser takes in a set of tokens, as generated by the
  ConditionLexer.parse method, and makes sure that the condition is valid.  If
  the condition sentence does not match the condition grammer, an exception is
  raised.  Otherwise, a parse tree is created. */
  class ConditionParser {
    /**
     * Parse the tokens (as an object) and return a parse tree.  The condition
     * must follow the following grammar.
     *
     * &lt;pre>
     *   &amp;lt;condition&amp;gt;                ::= "{" &amp;lt;comparison&amp;gt; | &amp;lt;null-comparison&amp;gt; | &amp;lt;in-comparison&amp;gt; | &amp;lt;logical-condition&amp;gt; "}"
     *   &amp;lt;comparison&amp;gt;               ::= &amp;lt;comparison-operator&amp;gt; ":" "{" &amp;lt;column&amp;gt; ":" &amp;lt;value&amp;gt; "}"
     *   &amp;lt;null-comparison&amp;gt;          ::= &amp;lt;null-comparison-operator&amp;gt; ":" "{" &amp;lt;column&amp;gt; ":" &amp;lt;nullable&amp;gt; "}"
     *   &amp;lt;in-comparison&amp;gt;            ::= &amp;lt;in-comparison-operator&amp;gt; ":" "{" &amp;lt;column&amp;gt; ":" "[" &amp;lt;value&amp;gt; {"," &amp;lt;value&amp;gt;} "]" "}"
     *   &amp;lt;logical-condition&amp;gt;        ::= &amp;lt;boolean-operator&amp;gt; ":" "[" &amp;lt;condition&amp;gt; {"," &amp;lt;condition&amp;gt;} "]"
     *   &amp;lt;comparison-operator&amp;gt;      ::= "$eq" | "$neq" | "$lt" | "$lte" | "$gt" | "$gte" | "$like" | "$notlike"
     *   &amp;lt;in-comparison-operator&amp;gt;   ::= "$in"
     *   &amp;lt;null-comparison-operator&amp;gt; ::= "$is" | "$isnt"
     *   &amp;lt;boolean-operator&amp;gt;         ::= "$and" | "$or"
     *   &amp;lt;nullable&amp;gt;                 ::= null | &amp;lt;parameter&amp;gt;
     *   &amp;lt;value&amp;gt;                    ::= &amp;lt;parameter&amp;gt; | &amp;lt;column&amp;gt; | &amp;lt;number&amp;gt; | null
     *   &amp;lt;column&amp;gt;                   ::= &amp;lt;string&amp;gt;
     *   &amp;lt;parameter&amp;gt;                ::= :&amp;lt;string&amp;gt;
     * &lt;/pre>
     *
     * @param {Object[]} tokens - An array of tokens, as created by the
     * ConditionLexer.parse method.
     * @return {Object} A parse tree.  Each node in the tree has a token and
     * children nodes.
     */
    parse(tokens) {
      this._tokenInd = 0;
      this._tokens   = tokens;
      this._token    = this._tokens[this._tokenInd];
      this._tree     = null;
      this._curNode  = null;

      // Parse the program, and return the resulting parse tree.
      this._condition();
      assert(this._token === null, this._errorString('EOL'));
      return this._tree;
    }

    // &lt;condition> ::= "{" &lt;comparison> | &lt;null-comparison> | &lt;in-comparison> | &lt;logical-condition> "}"
    _condition() {
      var pairParts = ['comparison-operator', 'null-comparison-operator', 'in-comparison-operator', 'boolean-operator'];

      this._charTerminal('{');
      assert(this._tokenIn(pairParts), this._errorString('[' + pairParts.join(' | ') + ']'));

      if (this._token.type === 'comparison-operator')
        this._comparison();
      else if (this._token.type === 'null-comparison-operator')
        this._nullComparison();
      else if (this._token.type === 'in-comparison-operator')
        this._inComparison();
      else
        this._logicalCondition();

      this._charTerminal('}');
    }

    // &lt;comparison> ::= &lt;comparison-operator> ":" "{" &lt;column> ":" &lt;value> "}"
    _comparison() {
      this._comparisonOperator();
      this._charTerminal(':');
      this._charTerminal('{');
      this._column();
      this._charTerminal(':');
      this._value();
      this._charTerminal('}');
    }

    // &lt;in-comparison> ::= &lt;in-comparison-operator> ":" "{" &lt;column> ":" "[" &lt;value> {"," &lt;value>} "]" "}"
    _inComparison() {
      this._inComparisonOperator();
      this._charTerminal(':');
      this._charTerminal('{');
      this._column();
      this._charTerminal(':');
      this._charTerminal('[');
      this._value();
      while (this._token.value === ',') {
        this._charTerminal(',');
        this._value();
      }
      this._charTerminal(']');
      this._charTerminal('}');
    }

    // &lt;null-comparison> ::= &lt;null-comparison-operator> ":" "{" &lt;column> ":" &lt;nullable> "}"
    _nullComparison() {
      this._nullComparisonOperator();
      this._charTerminal(':');
      this._charTerminal('{');
      this._column();
      this._charTerminal(':');
      this._nullable();
      this._charTerminal('}');
    }

    // &lt;logical-condition> ::= &lt;boolean-operator> ":" "[" &lt;condition> {"," &lt;condition>} "]"
    _logicalCondition() {
      this._booleanOperator();
      this._charTerminal(':');
      this._charTerminal('[');
      this._condition();
      // &lt;boolean-operator> is preceded by an array of &lt;condition>.  After adding each
      // &lt;condition> node make the &lt;boolean-operator> the current node.
      this._curNode = this._curNode.parent;
      while (this._token &amp;&amp; this._token.value === ',') {
        this._charTerminal(',');
        this._condition();
        this._curNode = this._curNode.parent;
      }
      this._charTerminal(']');
    }

    // &lt;comparison-operator> ::= "$eq" | "$neq" | "$lt" | "$lte" | "$gt" | "$gte"
    _comparisonOperator() {
      this._matchType('comparison-operator');
    }

    // &lt;in-comparison-operator> ::= "$in"
    _inComparisonOperator() {
      this._matchType('in-comparison-operator');
    }

    // &lt;null-comparison-operator> ::= "$is" | "$isnt"
    _nullComparisonOperator() {
      this._matchType('null-comparison-operator');
    }

    // &lt;boolean-operator> ::= "$and" | "$or"
    _booleanOperator() {
      this._matchType('boolean-operator');
    }

    // &lt;nullable> ::= null | &lt;parameter>
    _nullable() {
      var values = ['null', 'parameter'];
      assert(this._tokenIn(values), this._errorString('[' + values.join(' | ') + ']'));

      if (this._token.type === 'null')
        this._nullTerminal();
      else
        this._parameter();
    }

    // &lt;value> ::= &lt;parameter> | &lt;column> | &lt;number>
    _value() {
      var values = ['parameter', 'column', 'number'];
      assert(this._tokenIn(values), this._errorString('[' + values.join(' | ') + ']'));

      if (this._token.type === 'parameter')
        this._parameter();
      else if (this._token.type === 'column')
        this._column();
      else
        this._number();
    }

    // &lt;parameter> ::= :&lt;string>
    _parameter() {
      this._matchType('parameter');
    }

    // &lt;column> ::= &lt;string>
    _column() {
      this._matchType('column');
    }

    // Number terminal.
    _number() {
      this._matchType('number');
    }

    // Handles non-characters.  Verifies that the current token's type matches
    // the passed-in type.  If not, an exception is raised.  If so, the token is
    // advanced.
    _matchType(type) {
      assert(this._token !== null &amp;&amp; this._token.type === type, this._errorString(`&lt;${type}>`));
      this._addNode();
      this._advance();
    }

    // Handles the basic character terminals, which aren't needed in the
    // resulting sentence/tree.  These are the basic terminals: "{", "}", "[",
    // "]", ":", ","
    _charTerminal(c) {
      assert(this._token !== null &amp;&amp; c === this._token.value, this._errorString(c));
      this._advance();
    }

    // Checks that the current token is a null terminal.
    _nullTerminal() {
      assert(this._token !== null &amp;&amp; this._token.type === 'null', this._errorString('null'));
      this._addNode();
      this._advance();
    }

    // Move to the next token, or set token to null if the end of the sentence is
    // encountered.
    _advance() {
      assert(this._tokenInd &lt; this._tokens.length, 'Encountered the end of the sentence prematurely.');

      if (++this._tokenInd &lt; this._tokens.length)
        this._token = this._tokens[this._tokenInd];
      else
        this._token = null;
    }

    // Check if the current token matches one of the types on toks.
    _tokenIn(tokTypes) {
      return tokTypes.some(function(type) {
        return this._token.type === type;
      }, this);
    }

    // Helper to create an error string.
    _errorString(expected) {
      var type  = this._token ? this._token.type  : 'EOL';
      var value = this._token ? this._token.value : 'EOL';

      return `At index ${this._tokenInd}.  Expected ${expected} but found type ` +
             `${type} with value ${value}.`;
    }

    // Helper function to add a node to the parse tree.
    _addNode() {
      var node = {
        children: [],
        parent:   this._curNode,
        token:    this._token
      };

      // If there is no tree, this is the root node.
      if (this._tree === null) {
        this._tree = this._curNode = node;
        return;
      }

      // This node is a child of the current node.
      this._curNode.children.push(node);

      // If the current token is a non-terminal then make the new node the
      // current node.  The tree is structued with non-terminals having terminal
      // children.
      //        __$eq__
      //       /       \
      //    'name'   ':name'
      if (!this._token.terminal)
        this._curNode = node;
    }
  }

  return ConditionParser;
}

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BitConverter.html">BitConverter</a></li><li><a href="Column.html">Column</a></li><li><a href="ConditionCompiler.html">ConditionCompiler</a></li><li><a href="ConditionLexer.html">ConditionLexer</a></li><li><a href="ConditionParser.html">ConditionParser</a></li><li><a href="Database.html">Database</a></li><li><a href="DataContext.html">DataContext</a></li><li><a href="DataMapper.html">DataMapper</a></li><li><a href="Delete.html">Delete</a></li><li><a href="DeleteModel.html">DeleteModel</a></li><li><a href="Escaper.html">Escaper</a></li><li><a href="ForeignKey.html">ForeignKey</a></li><li><a href="From.html">From</a></li><li><a href="FromAdapter.html">FromAdapter</a></li><li><a href="Insert.html">Insert</a></li><li><a href="ModelTraverse.html">ModelTraverse</a></li><li><a href="MutateModel.html">MutateModel</a></li><li><a href="Query.html">Query</a></li><li><a href="QueryExecuter.html">QueryExecuter</a></li><li><a href="RelationshipStore.html">RelationshipStore</a></li><li><a href="Schema.html">Schema</a></li><li><a href="Select.html">Select</a></li><li><a href="Table.html">Table</a></li><li><a href="TableMetaList.html">TableMetaList</a></li><li><a href="Update.html">Update</a></li><li><a href="UpdateModel.html">UpdateModel</a></li><li><a href="UTCConverter.html">UTCConverter</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Sun Dec 04 2016 13:52:15 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
