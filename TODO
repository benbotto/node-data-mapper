-------------------------------------------------
Insert is in progress.  Sub-model inserts should work, but has not been tested.  An issue is that the toString() method will not accurately show the SQL, because only the top-level models are iterated over.  How can those be displayed?  The parent key does not exist...  Maybe wait until there are parameters, and then show the parametrized SQL?  Also, there is an issue with the way keys are updated.  Consider the photo table that has self-referencing keys for thumbnails.  Both of the keys are owned by the photos table, and both point to the photoID, so inserting a photo with thumbnails will set both of these keys on the child.  That's not correct...
On further thought, there are a number of issues with recursive inserts:

1) Self-referencing tables -- no way to determine insertion order, becuase both the parent and the child own the key.
2) Foreign keys that reference non-primary keys (not sure why someone would do this, but foreign keys can reference any unique column).
3) Security.  If used with web services, for example, this would allow malicious users to insert sub-objects that they shouldn't be inserting (potentially).

Here's the code, though, for child insertions (child-owned relationships only).

            // Update keys on the child if possible.
            traverse.modelOnly(queryDatum.modelMeta.model, function(cMeta) {
              // Get the relationships between the two tables that the child
              // table owns (parent-owned relationships are ignored).
              const cTbl = self.database.getTableByMapping(cMeta.tableMapping);
              const fks  = self.database.relStore.getRelationships(
                cTbl.name, tbl.name, true);

              fks.forEach(function(fk) {
                const cCol = cTbl.getColumnByName(fk.column);
                const pCol = tbl.getColumnByName(fk.references.column);

                // Foreign keys should always point to the parent ID, but just
                // in case the user has a strange relationship (in which case
                // the sub model is not inserted).
                if (pCol.name === tbl.primaryKey[0].name) {
                  // Set the referenced ID.
                  cMeta.model[cCol.mapTo] = result.insertId;

                  // Queue the child for insertion.
                  queueQueryData(cMeta);
                }
              });
            }, self.database);

--------------------------------------


Migrate condition builder to this project.

Provide a short-hand end() method on the DataContext and update all the examples/doc.

Make the code work with node-mssql (probably need to fix parameters).
  1) The ConditionCompiler replaces parameters with values.  That can't happen.
  2) As is, the same parameter name can be used in multiple parts of the query with different values (e.g. :name could be used in a WHERE condition and an ON condition).  Moving parameterization responsibility to another class (e.g. a QueryExecuter) would break this.
  3) Need to consider schema.  In MSSQL, schema can be important ([ddo].[mytable]).

Views don't work.  There is no primary key.

Everything related to MySQL should be moved to a separate project.  Right now ndm depends on mysql, and it shouldn't if the user is using another DB.

Composite keys are not supported by the Schema and will not work.  Needs impl.
When there are two top-level schemata two DataMappers are used.  This doubles the time because two loops are needed.  Performance would be better if the DataMapper could take an array of schemata and perform the mapping in a single loop.  On the other hand, two top-level schemata is a corner case.
It would be nice to allow multiple queries to be combinded into a single one.  With big queries, the cartisian product can be huge and it would be a performance enhancer to allow selecting from multiple related entities.
