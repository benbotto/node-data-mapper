UpdateModel creates an Update instance... that needs to be a MySQLUpdate instance.  Figure out how to specialize that.
CloneDB not needed in DataContext after refactor.
Implement buildQuery in Delete and use it in execute() and toString().  Then move buildQuery to the platform-specific modules.
Queries need to be built for the driver.  There are subtle differences (for example, UPDATE with JOIN differs between MySQL and MSSQL).

Need transaction support, but it's tricky with a pool.  The user may need to run multiple queries in a transaction, and so the connection needs to somehow be tied to the request.

Migrate condition builder to this project.

Provide a short-hand end() method on the DataContext and update all the examples/doc.

Make the code work with node-mssql (probably need to fix parameters).
  1) The ConditionCompiler replaces parameters with values.  That can't happen.
  2) As is, the same parameter name can be used in multiple parts of the query with different values (e.g. :name could be used in a WHERE condition and an ON condition).  Moving parameterization responsibility to another class (e.g. a QueryExecuter) would break this.
  3) Need to consider schema.  In MSSQL, schema can be important ([ddo].[mytable]).

Views don't work.  There is no primary key.

Composite keys are not supported by the Schema and will not work.  Needs impl.
When there are two top-level schemata two DataMappers are used.  This doubles the time because two loops are needed.  Performance would be better if the DataMapper could take an array of schemata and perform the mapping in a single loop.  On the other hand, two top-level schemata is a corner case.
It would be nice to allow multiple queries to be combinded into a single one.  With big queries, the cartisian product can be huge and it would be a performance enhancer to allow selecting from multiple related entities.
